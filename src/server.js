/*
 *
 *
 * (c) Copyright Merative US L.P. and others 2020-2022 
 *
 * SPDX-Licence-Identifier: Apache 2.0
 *
 */

const express = require('express');
const path = require('path');
const fs = require('fs');
const http = require('http');
const https = require('https');
const log4js = require('log4js');

const health = require('@cloudnative/health-connect');
const swaggerUI = require('swagger-ui-express');
const messageHandler = require('./service/messageHandler');
const config = require('./config');
const configValidator = require('./config/configValidator');
const CloudantHelper = require('./helpers/cloudant-helper');
const { registerChecks } = require('./helpers/health-checker');

// Configure swagger
const swaggerDoc = require('./swagger.json');

const usersRouter = require('./routes/users');
const failedConsentsRouter = require('./routes/failed-consents');
const consentStatusRouter = require('./routes/consent-status');

const devMode = process.env.DEV_MODE !== 'false';

const log = log4js.getLogger('Server');
log.level = config.logLevel;

const app = express();

// Configure express
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.disable('x-powered-by');

// Initiate database connection
const initDBConnection = async () => {
  try {
    const cloudantClient = CloudantHelper.getInstance();
    await cloudantClient.setupCloudant();
    await cloudantClient.checkConnection();
  } catch (err) {
    const errMsg = `Error starting server. Failed to setup Cloudant: ${err}`;
    log.error(errMsg);
  }
};

// Setups and validates the configuration properties.
configValidator.setup();

// Configure routes
app.use('/gateway-listener/api-docs', swaggerUI.serve, swaggerUI.setup(swaggerDoc));
app.use('/gateway-listener/api/v1/login', usersRouter);
app.use('/gateway-listener/api/v1/failed-consents', failedConsentsRouter);
if (devMode) {
  app.use('/gateway-listener/api/v1/consent-status', consentStatusRouter);
}

const healthcheck = new health.HealthChecker();
app.use('/gateway-listener/api/v1/health', health.HealthEndpoint(healthcheck));
app.use('/gateway-listener/api/v1/live', health.LivenessEndpoint(healthcheck));
app.use('/ready', health.ReadinessEndpoint(healthcheck));

app.use((_req, res) => {
  res.status(404).json({
    status: 404,
    message: 'Not Found',
  });
});

app.use((err, _req, res) => {
  log.error(err);

  res.status(500).json({
    status: 500,
    message: 'Internal server error',
  });
});

log.info('Starting server');

/*
 * To launch HTTPS server it requires
 * private key (tls.key) and certificate (tls.crt).
 * For test and local development these files can be generated by openssl tool.
 *
 * openssl genrsa -out key.pem
 * openssl req -new -key key.pem -out csr.pem
 * openssl x509 -req -days 9999 -in csr.pem -signkey key.pem -out cert.pem
 * rm csr.pem
 *
 * openssl genrsa -des3 -out server.key 1024
 * openssl req -new -key server.key -out server.csr
 * cp server.key server.key.org
 * openssl rsa -in server.key.org -out tls.key
 * openssl x509 -req -days 3650 -in server.csr -signkey tls.key -out tls.crt
 * rm -rf server.key.org
 * rm -rf server.csr
 */
let server;
let infoMessage;
if (config.httpsEnabled) {
  log.info('HTTPS enabled');

  const keyfile = path.join(__dirname, 'ssl', 'tls.key');
  const certFile = path.join(__dirname, 'ssl', 'tls.crt');

  const httpsOptions = {
    key: fs.readFileSync(keyfile),
    cert: fs.readFileSync(certFile),
  };

  server = https.createServer(httpsOptions, app);
  infoMessage = `HTTPS server started on port: ${config.port}`;
} else {
  server = http.createServer(app);
  infoMessage = `Server up on port: ${config.port}`;
}
server.listen(config.port, () => {
  messageHandler.start();
  initDBConnection();
  registerChecks(health, healthcheck);
  log.info(infoMessage);
});

// Handle shutdown signals. Safely shutting down processes and closing connections
const signalTraps = ['SIGTERM', 'SIGINT', 'SIGUSR2'];

signalTraps.forEach((type) => {
  process.once(type, async () => {
    try {
      log.info(`Received kill '${type}' signal, shutting down gracefully`);
      server.close((err) => {
        if (err) {
          log.error(`An error while shutting down: ${err}`);
          process.exit(1);
        }
        process.exit(0);
      });
      log.info(`Stopping application on ${type} signal`);
      await messageHandler.shutdown();
    } finally {
      process.kill(process.pid, type);
    }
  });
});

module.exports = server;
